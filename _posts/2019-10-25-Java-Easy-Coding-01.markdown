---
layout:       post
title:        "码出高效 Java开发手册-学习笔记01"
subtitle:     "聊一聊面向对象"
date:         2019-10-25 11:30:00
author:       "sunpwork"
header-mask:  0.3
catalog:      true
tags:
    - Java
    - 码出高效
    - 面向对象

---
>最近在公司准备转后端岗，公司的后端大佬让我买本《码出高效 Java开发手册》自己先看一看，到时候会有考核。这两天正好开发任务不是很重，就翻阅了看了看，确实质量很高。之前在学校里面学Java也是野路子出身，没有系统化的学习过，正好通过这本书来查漏补缺。立个flag，这两个月会不定期的更新学习笔记。

# 面向对象（OOP）理念
在编程语言的发展过程中，首先出现的是面向过程思想，面向过程让计算机有步骤地做一件事情，是一种过程话的叙事思维。但是在开发过程中，软件维护、软件复用存在着巨大的困难，模块之间互相耦合，流程互相穿插，牵一发而动全身。面向对象提出了从人类思维角度提出解决问题的步骤和方案。

书上是拿开门这个动作举例的，面向过程是`open(Door door)`，动宾结构，`door`是被作为操作对象的参数传入方法的，方法内定义开门的具体步骤实现。而在面向对象的世界里，首先先定义一个`Door`对象，然后抽象出门的属性和相关操作，属性可以包括尺寸、颜色、开启方式等等；操作包括`open()`和`close()`两个必备的行为，是主谓结构。

传统意义上，面向对象有三大特性：封装、继承、多态。这本书将“抽象”作为面向对象的特性之一加入。封装是一种对象功能内聚的表象形式，使模块之间耦合度变低；继承使子内能够继承父类，获得父类的部分属性和行为，使模块更有复用性；多态使模块在复用性基础上更加有拓展性，使系统运行更有想象空间。而抽象是归纳和演绎的过程，是面向对象思想最基础的能力之一，正确而严谨的业务抽象和建模分析能力是后续的封装、继承、多态的基础。

# Java中的类
## 类的定义
类的定义有访问级别、类型、类名、是否抽象、是否静态、泛型标识、继承或实现关键字、父类或接口名称等组成。Java类主要有两个组成部分：成员和方法。在定义Java类时，推荐首先定义变量，然后定义方法。公有方法是类的调用者和维护者最关心的，因此最好首屏展示；保护方法虽然只被子类关心，但也可能是模版设计模式下的核心方法，重要性仅次于公有方法；私有方法对外部来说是一个黑盒实现，因此不需要被特别关注；最好是`getter/setter`方法，虽然他们也是公有方法，但是承载的价值比较低，所以放在类最后。

## 接口和抽象类
定义类的过程是抽象和封装的过程，而接口和抽象类则是对实体类进行更高层次的抽象，仅定义公共行为和特征。接口和抽象类的共同点是都不能被实例化，但都可以定义引用变量指向实例对象。

| 语法维度 | 抽象类 | 接口 |
| ------- | ------- | ------- |
|   定义关键字  |   abstract  |   interface  |
|   子类继承或实现关键字  |   extends  |   implements  |
|  方法实现  |  可以有  |  不可有，jdk8之后，允许有default实现  |
|  方法访问控制符   |无限制   |  有限制，默认是public abstract 类型  |
|  属性访问控制符  |  无限制  |  有限制，默认是public static final  |
|  静态方法   |  可以有   |  不能有，jdk8之后允许有   |
|  static{}静态代码块  |  可以有  | 不能有   |
|  本类型之间扩展  |  单继承  |  多继承  |
|  本类型之间扩展关键字  |  extends  |  extends  |


抽象类在被继承时体现的是`is-a`关系，接口在被实现时体现的是`can-do`关系。接口说顶级的“类”，虽然关键字是`interface`，但是编译之后的字节码扩展名还是 .class。抽象类是二当家，接口位于顶层，而抽象类对各个接口进行了组合，然后实现部分接口行为，其中`AbstractCollection`是最典型的抽象类：

```Java
public abstract class AbstractCollection<E> implements Collection<E> {
	// Collection 定义的抽象方法，但本内没有实现
	// Collection 接口定义的方法，size()这个方法对于链表和顺序表有不同的实现方式
	public abstract int size();
	
	// 实现Collection接口的这个方法，因为对AbstractCollection的子类他们判空的方式是一致的
	public boolean isEmpty(){
		// 通过多态调用到子类的具体size()方法
		return size() == 0;
	}
}
```
Java语言中类的继承采用单继承形式，避免继承泛滥、菱形继承、循环继承，甚至“四不像”实现类的出现。在JVM中，一个类如果有多个直接父类，那么方法的绑定机制会变得非常复杂，接口继承接口，关键字是`extends`，而不是`implements`，允许多重继承，是因为接口有契约式的行为约定，没有任何具体实现和属性，某个实体类实现多重继承后的接口时，只是说明"can do many things"。

## 内部类
在一个 .java 源文件中，只能定义一个类名与文件名完全一致的公开类，使用`public class`关键字来修饰。在面向对象语言中，任何一个类都可以在内部定义另外一个类，前者为外部内，后者为内部类。内部类本身就是类的一个属性。`private static String str`，由访问控制符、是否静态、类型、变量名组成，而内部类`private static class Inner{}`，也是按这样的顺序来定义的。内部类可以是静态的和非静态的，他可以出现在属性定义、方法体和表达式中，甚至可以匿名出现，具体分为以下四种：

- 静态内部类 如：`static class StaticInnerClass{};` 
- 成员内部类 如：`private class InstanceInnerClass{};`
- 局部内部类 定义在方法或者表达式内部
- 匿名内部类 如：`(new Thread(){}).start()`

匿名内部类（启动线程等）和静态内部类（外部使用`OuterClass.StaticInnerClass`直接访问）是比较常见的内部类使用方式。在JDK源码中，定义包内可见静态内部类的方式很常见，这样做的好处是：

- 作用域不会扩散到包外
- 可以通过`外部类.内部类`的方式直接访问
- 内部类可以访问外部类的所有静态属性和方法

```Java
static class Node<K,V> implements Map.Entry<K,V>{
	final int hash;
	final K key,
	volatile V val;
	valotile Node<K,V> next;
}
```
如上所示的源码在`ConcurrentHashMap`中定义的Node静态内部类，用于表示一个节点数据，属于包内可见。Node的父类Entry上Map的静态内部类，之所以可以被Node继承是因为两个外部类同属一个包。

## 访问控制权限

| 访问权限控制符 | 任何地方 | 包外子类 | 包内 | 类内 |
| ------- | ------- | ------- | ------- | ------- |
| public | OK | OK | OK | OK |
| protected | NO | OK | OK | OK |
| 无 | NO | NO | OK | OK |
| private | NO | NO | NO | OK |
*private 修饰的属性和方法在同一包内，即使并非继承关系也是可见的。*

## this与super

| | this | super |
| ------- | ------- | ------- |
| 基本概念 | 访问本类实例的属性和方法 | 由子类访问父类中的实例属性和方法 |
| 查找范围| 先找本类，没有则找父类 | 直接查找父类 |
| 特殊功能 | 单独使用时，表示当前对象 | 在子类覆写父类方法时，可以访问父类同名方法  |
`this`和`super`的相同点：

- 都是关键字，起指代作用
- 在构造方法中必须出现在第一行

## 类关系
类的关系分为以下6种

- 继承 extends (is-a)
- 实现 implements(can-do)
- 组合 类时成员变量(contains-a)
- 聚合 类时成员变量(has-a)
- 依赖 除了组合和聚合外的单向弱关系。比如使用另一个类的属性、方法，或以其作为方法的参数输入，或以其作为方法的返回值输出(depends-a)
- 关联 互相平等的依赖关系(links-a)

## 序列化
内存中的数据对象只有转换为二进制流才可以进行数据持久化的网络传输。将数据转换为二进制的过程称为对象的序列化。反之，将二进制流恢复为数据对象的过程称为反序列化。常见的序列号方式有三种：

- Java原生序列号。Java类通过实现`Serializable`接口来实现该类对象的序列化，这个接口非常特殊，没有任何方法，只起到了标识作用。Java序列化保留了对象类的元数据（如类、成员变量、继承类信息等），以及对象数据等，兼容性最好，但不能跨语言，性能一般。
- Hession序列化。Hession序列化时一种支持动态类型、跨语言、基于对象传输等网络协议。Hession会把复杂对象所有的属性存储在一个Map中进行序列化。所以在父类、子类存在同名成员变量的情况下，Hession序列化时，先序列化子类，然后序列化父类，因此反序列化结果会导致子类同名成员变量被父类的值覆盖。
- JSON序列化。JSON(JavaScript Object Notation)是一种轻量级的数据交换格式。JSON序列化就是将数据对象转换为JSON字符串。在序列化的过程中抛弃了类型信息，所以反序列化时只有提供类型信息才能准确地反序列化。相比前两种方式，JSON可读性比较好，方便调试。

# 方法
## 方法签名
方法签名包括方法名称和参数列表，是JVM标识方法的唯一索引，不包括返回值，更加不包括访问权限控制符、异常类型等。

## 参数
基本的概念就不多说了，这里要注意一点：无论对于基本数据类型，还是引用对象，Java中的参数传递都是值复制的传递过程。对于引用变量，复制指向对象的首地址，双方都可以通过自己的引用变量修改指向对象的相关属性。总结一下如下：

- 一个方法不能修改基本数据类型的参数
- 一个方法可以改变一个对象参数的状态
- 一个方法不能让对象参数引用另一对象

再来介绍一种特殊的参数——可变参数。可变参数通过`参数类型... `的方式定义，如`PrintStream`类中的`printf`方法就使用了可变参数：

```Java
public PrintStream printf(String format, Object... args){
	return format(format, args);
}
// 调用示例
System.out.printf("%d", n);
System.out.printf("%d %s", n, "something");
```

## 构造方法
构造方法(Constructor)是方法名与类名相同的特殊方法，在新建对象时调用，可以通过不同的构造方法实现不同方式的对象初始化，构造方法有如下特征：

- 构造方法名称必须与类名相同
- 构造方法没有返回值，void也不能有
- 构造方法不能被继承，不能被覆写，不能被直接调用。
- 类定义时提供了默认的无参构造方法
- 构造方法可以私有 外部无法使用私有构造方法创建对象（如单例模式的实现）

类中的`static{...}`代码被称为类的静态代码块，在类初始化时执行，优先级很高。下面看一下父子类静态代码块和构造方法的执行顺序：

```Java
class Son extends Parent{
	static { System.out.println("Son 静态代码块"); }
	Son() { System.out.println("Son 构造方法"); }
	
	public static void main(String[] args){
		new Son();
		new Son();
	}
}
class Parent{
	static { System.out.println("Parent 静态代码块"); }
	public Parent() { System.out.println("Parent 构造方法"); }
}
```
执行结构如下：

```
Parent 静态代码块
Son 静态代码块
Parent 构造方法
Son 构造方法
Parent 构造方法
Son 构造方法
```
我们可以看出，在创建类对象时，会先执行父类和子类的静态代码块，然后在依次执行父类和子类的构造方法。静态代码块只会执行一次，在第二次实例化对象时，不会再执行。

## 类内方法
在面向过程的语言中，几乎所有的方法都是全局静态方法，在引入面向对象理念之后，某些方法才归属于具体对象，即类内方法。构造方法在一个类中时必然存在的。除了构造方法外，类中还可以有三类方法：实例方法、静态方法、静态代码块。

### 实例方法
一般我们称为非静态方法。实例方法比较简单，它必须依附于某个实例对象来调用。类内部各个实例方法之间可以相互调用，也可以直接读写类内变量。实例方法可以调用静态方法和静态变量。

### 静态方法
我们又称为类方法。使用静态方法需要注意一下两点：

- 静态方法中不能调用非静态变量和非静态方法(实例方法)
- 静态方法不能使用`super`和`this`关键字

通常静态方法用于定义工具类的方法等，静态方法如果使用了可修改的对象，在并发时会存在线程安全问题。所以，工具类的静态方法与单例通常是相伴而生的。

### 静态代码块
在代码的执行方法体中，非静态代码块和静态代码比较特殊。非静态代码块是极不推荐使用的处理方式。而静态代码块在类加载的时候就被调用，并且只执行一次。静态代码块是先与构造方法执行的特殊代码块。

## setter与getter
setter和getter方法是为类成员属性提供读取和修改的方法，这样设计的好处如下：

- 满足面向对象语言封装的特性
- 有利于统一控制 例如要求对某个属性的值的修改增加统一的权限控制

getter和setter方法的定义非常简单，正因如此，工程师会放松对他们的警惕。下面是在使用getter和setter需要避免的操作：

- getter/setter 中应该避免添加业务逻辑，这会增加排查问题的难度，工程师往往到最后才会去排查这两个方法是否有问题
- 同时定义`isXXX()`和`getXXX()`，这会导致在某些框架(IBATIS)，JSON反序列化中引起冲突而出错。

## 同步和异步

- 同步调用是阻塞式操作，必须等待调用方法体执行结束。
- 异步调用式非阻塞式操作，在执行过程中，如调用其他方法，自己可以继续执行而不被阻塞等待方法调用完毕

## 覆写
多态中的override。如果父类定义的方法达不到子类的期望，那么子类可以重现实现方法覆盖父类的实现，这就叫覆写。如果某个类覆写类父类的某个方法，则方法表中的方法指向引用会指向子类的实现处。代码通常是用这样的方式来调用子类的方法，通常这也被称为向上转型。向上转型时，通过父类引用执行子类方法时需要注意以下两点：

- 无法调用到子类中执行子类本身而不存在的方法
- 可以调用到子类中覆盖了父类的方法，这是一种多态的实现。

想要成功覆写父类方法，需要满足以下4个条件：

- 访问权限不能变小
- 返回类型能够向上转型成父类的返回类型。即覆写的方法返回值只能与父类相同或者是父类返回值类型的子类。
- 异常也要向上转型称为父类的异常。同上
- 方法名、参数类型和个数必须严格一致。为了使编译器准确地判断是否是覆写行为，所有的覆写方法必须加上@Override注解。此时编译器会自动检查覆写方法签名是否一致。

覆写只能针对非静态、非final、非构造方法。由于静态方法属于类，如果父类和子类存在同名静态方法，那么两者都可以被正常调用。如果方法有final修饰，则表示此方法不可被覆写。